/**
 * @file pid.h
 * @brief PID Controller Library Header File
 * 
 * This file defines a fully functional PID controller class that supports 
 * multiple PID algorithm variants including standard PID, measurement-based PID,
 * weighted PID, and other advanced modes. This library can be used for microcontrollers 
 * like the STM32 or AVR, as well as other embedded systems.
 * 
 * @author WilliTourt willitourt@foxmail.com
 * @version 1.1
 * @date 2025.11.26
 * 
 * @note Comments are mostly generated by AI
 * 
 * @CHANGELOG:
 * - 1.0: Completed basic C implementation of PID controller with integral
 *        limit and separation modes.
 * - 1.1: Changed C implementation to C++ and added other mode options.
 * 
 */

/**
 * Formulations and equations of PID controller:
 * 
 * Standard: u(t) = Kp*e(t) + Ki*∫e(t)dt + Kd*de(t)/dt
 *                = P + I + D
 * 
 * Where:
 * u(t) is the output
 * e(t) = target - measurement
 * de(t)/dt = (e(t) - e(t-1))/dt
 *          = d(target)/dt - d(measurement)/dt
 * ∫e(t)dt = (e(t-1) + e(t-2) + ... + e(0)) * dt
 * dt is the sample time
 * Kp, Ki, Kd are gains
 * 
 * 
 * 
 * Other formulations:
 * 
 * - Proportional on measurement:
 *      P = - Kp * measurement
 * 
 * - Weighted proportional:
 *      P = Kp*(b * target - measurement)
 *      where b is a weighting factor between 0 and 1
 * 
 * 
 * - Integral clamped:
 *      I = Ki * min(∫e(t)dt, upperLimit)
 *
 * - Conditional integral:
 *      I = Ki*∫e(t)dt, if e(t) < error threshold, 0 otherwise
 * 
 * 
 * - Derivative on measurement:
 *      D = - Kd * d(measurement)/dt
 * 
 * - Weighted derivative:
 *      D = Kd*(c * d(target)/dt - d(measurement)/dt)
 *      where c is a weighting factor between 0 and 1
 * 
 */

#pragma once

#include <cmath>

/** @brief Default sample time for PID controller (1.0 second) */
#define PID_DEFAULT_SAMPLE_TIME 1.0f

/** @brief Default proportional weight for weighted proportional mode */
#define PID_DEFAULT_PROP_WEIGHT 1.0f

/** @brief Default integral clamping limit for clamped integral mode */
#define PID_DEFAULT_CLAMP_INT_LIMIT 200.0f

/** @brief Default error threshold for conditional integral mode */
#define PID_DEFAULT_COND_INT_ERR_THRESHOLD 20.0f

/** @brief Default derivative weight for weighted derivative mode */
#define PID_DEFAULT_DERIVATIVE_WEIGHT 1.0f

/** @brief Default deadzone value (no deadzone) */
#define PID_DEFAULT_DEADZONE 0.0f

/**
 * @class PIDCtrller
 * @brief PID Controller class with multiple algorithm variants
 * 
 * This class implements a comprehensive PID controller with support for various
 * proportional, integral, and derivative modes. It provides flexible configuration
 * options and advanced features like deadzone handling and output limiting.
 */
class PIDCtrller {
    public:

        /**
         * @enum ProportionalMode_t
         * @brief Proportional term calculation modes
         */
        enum class ProportionalMode_t {
            Standard,        /**< Standard proportional: P = Kp * error */
            OnMeasurement,   /**< Proportional on measurement: P = -Kp * measurement */
            Weighted         /**< Weighted proportional: P = Kp*(b*target - measurement) */
        };

        /**
         * @enum IntegralMode_t
         * @brief Integral term calculation modes
         */
        enum class IntegralMode_t {
            Standard,    /**< Standard integral: I = Ki * ∫error dt */
            Clamped,     /**< Clamped integral: I = Ki * min(∫error dt, limit) */
            Conditional  /**< Conditional integral: I = Ki * ∫error dt only if |error| < threshold */
        };

        /**
         * @enum DerivativeMode_t
         * @brief Derivative term calculation modes
         */
        enum class DerivativeMode_t {
            Standard,        /**< Standard derivative: D = Kd * d(error)/dt */
            OnMeasurement,   /**< Derivative on measurement: D = -Kd * d(measurement)/dt */
            Weighted         /**< Weighted derivative: D = Kd*(c*d(target)/dt - d(measurement)/dt) */
        };

        /**
         * @brief Constructor for PID controller
         * @param kp Proportional gain
         * @param ki Integral gain
         * @param kd Derivative gain
         */
        PIDCtrller(float kp, float ki, float kd);

        /**
         * @brief Set PID gains
         * @param kp Proportional gain
         * @param ki Integral gain
         * @param kd Derivative gain
         */
        void setParams(float kp, float ki, float kd);

        /**
         * @brief Set the target value for the controller
         * @param target Desired target value
         */
        void setTarget(float target);

        /**
         * @brief Set the sample time for the controller
         * @param sample_time Time between calculations in seconds
         * @note Sample time must be positive. If <= 0, default value is used.
         */
        void setSampleTime(float sample_time);

        /**
         * @brief Set proportional mode without weight parameter
         * @param mode Proportional mode to set
         * @note For Weighted mode, use the overloaded version with weight parameter
         */
        void setProportionalMode(ProportionalMode_t mode);

        /**
         * @brief Set proportional mode with weight parameter
         * @param mode Proportional mode to set
         * @param weight Weight parameter for weighted proportional mode
         */
        void setProportionalMode(ProportionalMode_t mode, float weight);

        /**
         * @brief Set integral mode without additional parameter
         * @param mode Integral mode to set
         * @note For Clamped or Conditional modes, use the overloaded version with value parameter
         */
        void setIntegralMode(IntegralMode_t mode);

        /**
         * @brief Set integral mode with additional parameter
         * @param mode Integral mode to set
         * @param value Limit value for clamped mode or threshold for conditional mode
         */
        void setIntegralMode(IntegralMode_t mode, float value);

        /**
         * @brief Set derivative mode without weight parameter
         * @param mode Derivative mode to set
         * @note For Weighted mode, use the overloaded version with weight parameter
         */
        void setDerivativeMode(DerivativeMode_t mode);

        /**
         * @brief Set derivative mode with weight parameter
         * @param mode Derivative mode to set
         * @param weight Weight parameter for weighted derivative mode
         */
        void setDerivativeMode(DerivativeMode_t mode, float weight);

        /**
         * @brief Set deadzone for error calculation
         * @param deadzone Deadzone value (absolute value will be used)
         * @note If error is within deadzone, it's treated as zero
         */
        void setDeadzone(float deadzone);

        /**
         * @brief Calculate PID output based on current measurement
         * @param curr_measurement Current measurement value
         * @param upperLimit Upper limit for output clamping
         * @param lowerLimit Lower limit for output clamping
         * @return Calculated PID output value (clamped between limits)
         * @note If lowerLimit > upperLimit, they are automatically swapped
         */
        float calc(float curr_measurement, float upperLimit, float lowerLimit);

        /**
         * @brief Reset controller state (clear integrals and previous values)
         * @note Target value is preserved, only internal state is reset
         */
        void reset();

        /**
         * @brief Get the last calculated output value
         * @return Last output value from calc() function
         */
        inline float getLastOutput() const { return _output; }

        /**
         * @brief Get the current error value
         * @return Current error (target - measurement)
         */
        inline float getError() const { return _error; }

        /**
         * @brief Get the current integral value
         * @return Current accumulated integral value
         */
        inline float getIntegral() const { return _error_integral; }

    private:
        /** @brief Proportional, integral, and derivative gains */
        float _kp, _ki, _kd;
        
        /** @brief Sample time between calculations (seconds) */
        float _sample_time;

        /** @brief Last calculated output value */
        float _output;
        
        /** @brief Target value for the controller */
        float _target;
        
        /** @brief Current error, accumulated integral, and previous error */
        float _error, _error_integral, _prev_error;
        
        /** @brief Previous measurement and target values for derivative calculation */
        float _prev_measurement, _prev_target;

        /** @brief Weight parameter for weighted proportional mode */
        float _proportional_weight;
        
        /** @brief Limit value for clamped integral mode */
        float _clamped_integral_limit;
        
        /** @brief Error threshold for conditional integral mode */
        float _cond_integral_error_threshold;
        
        /** @brief Weight parameter for weighted derivative mode */
        float _derivative_weight;

        /** @brief Current proportional calculation mode */
        ProportionalMode_t _proportional_mode;
        
        /** @brief Current integral calculation mode */
        IntegralMode_t _integral_mode;
        
        /** @brief Current derivative calculation mode */
        DerivativeMode_t _derivative_mode;

        /** @brief Deadzone value for error calculation */
        float _deadzone;

};
