/**
 * @file pid.cpp
 * @brief PID Controller Library Header File
 * 
 * This file defines a fully functional PID controller class that supports 
 * multiple PID algorithm variants including standard PID, measurement-based PID,
 * weighted PID, and other advanced modes. This library can be used for microcontrollers 
 * like the STM32 or AVR, as well as other embedded systems.
 * 
 * @author WilliTourt willitourt@foxmail.com
 * @version 1.1
 * @date 2025.11.26
 * 
 * @note Comments are mostly generated by AI
 * 
 * @CHANGELOG:
 * - (See pid.h for changelog)
 */


#include "pid.h"

/**
 * @brief Constructor implementation - initializes PID controller with gains
 * @param kp Proportional gain
 * @param ki Integral gain
 * @param kd Derivative gain
 */
PIDCtrller::PIDCtrller(float kp, float ki, float kd) :
    _kp(kp), _ki(ki), _kd(kd),
    _sample_time(PID_DEFAULT_SAMPLE_TIME),
    _output(0.0f),
    _target(0.0f),
    _error(0.0f), _error_integral(0.0f), _prev_error(0.0f),
    _prev_measurement(0.0f), _prev_target(0.0f),
    _proportional_weight(PID_DEFAULT_PROP_WEIGHT),
    _clamped_integral_limit(PID_DEFAULT_CLAMP_INT_LIMIT),
    _cond_integral_error_threshold(PID_DEFAULT_COND_INT_ERR_THRESHOLD),
    _derivative_weight(PID_DEFAULT_DERIVATIVE_WEIGHT),
    _proportional_mode(ProportionalMode_t::Standard),
    _integral_mode(IntegralMode_t::Standard),
    _derivative_mode(DerivativeMode_t::Standard),
    _deadzone(PID_DEFAULT_DEADZONE) {
        if (_sample_time <= 0.0f) { _sample_time = PID_DEFAULT_SAMPLE_TIME; }
    }

/**
 * @brief Set PID gains implementation
 * @param kp Proportional gain
 * @param ki Integral gain
 * @param kd Derivative gain
 */
void PIDCtrller::setParams(float kp, float ki, float kd) {
    _kp = kp;
    _ki = ki;
    _kd = kd;
}

/**
 * @brief Set target value implementation
 * @param target Desired target value
 */
void PIDCtrller::setTarget(float target) {
    _prev_target = _target;
    _target = target;
}

/**
 * @brief Set sample time implementation
 * @param sample_time Time between calculations in seconds
 */
void PIDCtrller::setSampleTime(float sample_time) {
    if (sample_time <= 0.0f) { sample_time = PID_DEFAULT_SAMPLE_TIME; }
    _sample_time = sample_time;
}

/**
 * @brief Set proportional mode without weight implementation
 * @param mode Proportional mode to set
 */
void PIDCtrller::setProportionalMode(ProportionalMode_t mode) {
    _proportional_mode = mode;
}

/**
 * @brief Set proportional mode with weight implementation
 * @param mode Proportional mode to set
 * @param weight Weight parameter for weighted proportional mode
 */
void PIDCtrller::setProportionalMode(ProportionalMode_t mode, float weight) {
    _proportional_mode = mode;
    _proportional_weight = weight;
}

/**
 * @brief Set integral mode without additional parameter implementation
 * @param mode Integral mode to set
 */
void PIDCtrller::setIntegralMode(IntegralMode_t mode) {
    _integral_mode = mode;
}

/**
 * @brief Set integral mode with additional parameter implementation
 * @param mode Integral mode to set
 * @param value Limit value for clamped mode or threshold for conditional mode
 */
void PIDCtrller::setIntegralMode(IntegralMode_t mode, float value) {
    _integral_mode = mode;

    if (mode == IntegralMode_t::Clamped) {
        _clamped_integral_limit = fabs(value);
    } else if (mode == IntegralMode_t::Conditional) {
        _cond_integral_error_threshold = fabs(value);
    }
}

/**
 * @brief Set derivative mode without weight implementation
 * @param mode Derivative mode to set
 */
void PIDCtrller::setDerivativeMode(DerivativeMode_t mode) {
    _derivative_mode = mode;
}

/**
 * @brief Set derivative mode with weight implementation
 * @param mode Derivative mode to set
 * @param weight Weight parameter for weighted derivative mode
 */
void PIDCtrller::setDerivativeMode(DerivativeMode_t mode, float weight) {
    _derivative_mode = mode;
    _derivative_weight = weight;
}

/**
 * @brief Set deadzone implementation
 * @param deadzone Deadzone value (absolute value will be used)
 */
void PIDCtrller::setDeadzone(float deadzone) {
    if (deadzone < 0.0f) { deadzone = -deadzone; }
    _deadzone = deadzone;
}

/**
 * @brief Reset controller state implementation
 */
void PIDCtrller::reset() {
    _output = 0.0f;
    _error = 0.0f;
    _error_integral = 0.0f;
    _prev_error = 0.0f;
    _prev_measurement = 0.0f;
    _prev_target = _target;
}

/**
 * @brief Calculate PID output implementation
 * @param curr_measurement Current measurement value
 * @param upperLimit Upper limit for output clamping
 * @param lowerLimit Lower limit for output clamping
 * @return Calculated PID output value
 */
float PIDCtrller::calc(float curr_measurement, float upperLimit, float lowerLimit) {
    if (lowerLimit > upperLimit) {
        float temp = lowerLimit;
        lowerLimit = upperLimit;
        upperLimit = temp;
    }

    _error = _target - curr_measurement;

    if (std::fabs(_error) < _deadzone) {
        _error = 0.0f;
        _prev_error = 0.0f;
    }

    float delta_e = _error - _prev_error;
    float delta_m = curr_measurement - _prev_measurement;

    // P
    float p = 0.0f;
    switch (_proportional_mode) {
        case ProportionalMode_t::Standard:
            p = _kp * _error;
            break;
        case ProportionalMode_t::OnMeasurement:
            p = -_kp * curr_measurement;
            break;
        case ProportionalMode_t::Weighted:
            p = _kp * (_proportional_weight * _target - curr_measurement);
            break;
    }

    // I
    float i = 0.0f;
    switch (_integral_mode) {
        case IntegralMode_t::Standard:
            _error_integral += _error * _sample_time;
            break;
        case IntegralMode_t::Clamped:
            _error_integral += _error * _sample_time;
            if (std::fabs(_error_integral) > _clamped_integral_limit) {
                _error_integral = (_error_integral > 0.0f) ? _clamped_integral_limit : -_clamped_integral_limit;
            }
            break;
        case IntegralMode_t::Conditional:
            if (std::fabs(_error) < _cond_integral_error_threshold) {
                _error_integral += _error * _sample_time;
            }
            break;
    }
    i = _ki * _error_integral;

    // D
    float d = 0.0f;
    switch (_derivative_mode) {
        case DerivativeMode_t::Standard:
            d = _kd * delta_e / _sample_time;
            break;
        case DerivativeMode_t::OnMeasurement:
            d = -_kd * delta_m / _sample_time;
            break;
        case DerivativeMode_t::Weighted:
            d = _kd * (_derivative_weight * (_target - _prev_target) - delta_m) / _sample_time;
            break;
    }

    // Save previous values
    _prev_measurement = curr_measurement;
    _prev_error = _error;

    // Output
    _output = p + i + d;

    if (_output > upperLimit) { _output = upperLimit; }
    if (_output < lowerLimit) { _output = lowerLimit; }

    return _output;
}
